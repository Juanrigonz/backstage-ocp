'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendCommon = require('@backstage/backend-common');
var integration = require('@backstage/integration');
var Router = require('express-promise-router');
var httpProxyMiddleware = require('http-proxy-middleware');
require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);

function getBasePath(config) {
  const baseUrl = config.getOptionalString("backend.baseUrl");
  if (!baseUrl) {
    return void 0;
  }
  return new URL(baseUrl).pathname.replace(/\/$/, "");
}
async function createRouter(options) {
  const { logger, config } = options;
  const secure = config.getOptionalBoolean("gitlab.proxySecure");
  const basePath = getBasePath(config) || "";
  const gitlabIntegrations = integration.readGitLabIntegrationConfigs(
    config.getConfigArray("integrations.gitlab")
  );
  const router = Router__default["default"]();
  const filter = (_pathname, req) => {
    if (req.headers["authorization"])
      delete req.headers["authorization"];
    return req.method === "GET";
  };
  for (const { host, apiBaseUrl, token } of gitlabIntegrations) {
    const apiUrl = new URL(apiBaseUrl);
    router.use(
      `/${host}`,
      httpProxyMiddleware.createProxyMiddleware(filter, {
        target: apiUrl.origin,
        changeOrigin: true,
        headers: {
          ...token ? { "PRIVATE-TOKEN": token } : {}
        },
        secure,
        logProvider: () => logger,
        pathRewrite: {
          [`^${basePath}/api/gitlab/${host}`]: apiUrl.pathname
        }
      })
    );
  }
  router.use(backendCommon.errorHandler());
  return router;
}

function getProjectPath(target) {
  const url = new URL(target);
  return url.pathname.split("/blob/").splice(0, 1).join("/").split("/-").splice(0, 1).join("/").slice(1);
}

const GITLAB_PROJECT_SLUG = "gitlab.com/project-slug";
const GITLAB_PROJECT_ID = "gitlab.com/project-id";
const GITLAB_INSTANCE = "gitlab.com/instance";

class GitlabFillerProcessor {
  constructor(config) {
    const allowedKinds = config.getOptionalStringArray(
      "gitlab.allowedKinds"
    ) || ["Component"];
    this.gitLabIntegrationsConfig = integration.readGitLabIntegrationConfigs(
      config.getConfigArray("integrations.gitlab")
    );
    this.allowedKinds = new Set(
      allowedKinds.map((str) => str.toLowerCase())
    );
  }
  getProcessorName() {
    return "GitlabFillerProcessor";
  }
  async postProcessEntity(entity, location, _emit) {
    var _a, _b, _c;
    if (this.isAllowedEntity(entity)) {
      const gitlabInstance = this.getGitlabInstance(location.target);
      if (gitlabInstance) {
        if (!entity.metadata.annotations)
          entity.metadata.annotations = {};
        if (!((_a = entity.metadata.annotations) == null ? void 0 : _a[GITLAB_INSTANCE])) {
          entity.metadata.annotations[GITLAB_INSTANCE] = gitlabInstance;
        }
        if (!((_b = entity.metadata.annotations) == null ? void 0 : _b[GITLAB_PROJECT_ID]) && !((_c = entity.metadata.annotations) == null ? void 0 : _c[GITLAB_PROJECT_SLUG])) {
          entity.metadata.annotations[GITLAB_PROJECT_SLUG] = getProjectPath(location.target);
        }
      }
    }
    return entity;
  }
  getGitlabInstance(target) {
    let url;
    try {
      url = new URL(target);
    } catch (e) {
      return void 0;
    }
    const gitlabConfig = this.gitLabIntegrationsConfig.find((config) => {
      const baseUrl = config.baseUrl ? new URL(config.baseUrl) : new URL(`https://${config.host}`);
      return baseUrl.origin === url.origin;
    });
    return gitlabConfig == null ? void 0 : gitlabConfig.host;
  }
  isAllowedEntity(entity) {
    return this.allowedKinds.has(entity.kind.toLowerCase());
  }
}

exports.GitlabFillerProcessor = GitlabFillerProcessor;
exports.createRouter = createRouter;
//# sourceMappingURL=index.cjs.js.map
